1.已知入栈顺序1,2,3,4,5,6出栈顺序2,4,3,6,5,1，栈的大小至少为3
解：
	2出栈之前，栈里面有1,2。4出栈之前，栈里面有1,3,4.以此类推，至少有三个

2.hash散列的平均查找长度，先取余，再加起来。链地址法
解：
	取余之后的数为5,0,2,1,5,6,0,6,6,6,4
	0-->0,0(1+2第一个数查找1次，第二个数查找两次)
	以此类推
	总查找数除以长度就是平均查找长度
3.数据库保护主要内容：
	数据库的安全性
	完整性
	并发控制
	数据库恢复
4.hash线性探测再散列，如果有多个取余之后相同的，就往后面移，哪个为空，就往里面填。
5.多叉树转为二叉树，先将兄弟连起来，再讲父亲的最左儿子保留，断掉其他儿子。
6.98个已排序的数，采用二分查找法时，最大比较次数是。
7.二叉查找树的最好情况下的复杂度，最坏情况下的复杂度。
8.有表Person，要求删除姓名，年龄重复的记录（相同的保存id大的）

散列表的地址区间为0-17，散列函数为H(K) =K mod 17。采用线性探测法处理冲突，并将关键字序列26、25、72、38、8、18、59依次存储到散列表中。
元素59存放在散列表中的地址是（11）

设一个链表最常用的操作是在末尾插入结点和删除尾结点,则选用()最节省时间
带头结点的双循环链表

()的遍历仍需要栈的支持
正确答案: C   你的答案: 空 (错误)
前序线索树
中序线索树
后序线索树

用俩个栈模拟实现一个队列，如果栈的容量分别是O和P(O>P),那么模拟实现的队列最大容量是多少？
正确答案: C   你的答案: C (正确)
O+P
2O+1
2P+1
2O-1

以下叙述正确的是

正确答案: D   你的答案: C
实例方法可直接调用超类的实例方法
实例方法可直接调用超类的类方法、
实例方法可直接调用子类的实例方法
实例方法可直接调用本类的实例方法
A错误，类的实例方法是与该类的实例对象相关联的，不能直接调用，只能通过创建超类的一个实例对象，再进行调用
B错误，当父类的类方法定义为private时，对子类是不可见的，所以子类无法调用
C错误，子类具体的实例方法对父类是不可见的，所以无法直接调用， 只能通过创建子类的一个实例对象，再进行调用
D正确，实例方法可以调用自己类中的实例方法

public class Base
{
    private String baseName = "base";
    public Base()
    {
        callName();
    }

    public void callName()
    {
        System. out. println(baseName);
    }

    static class Sub extends Base
    {
        private String baseName = "sub";
        public void callName()
        {
            System. out. println (baseName) ;
        }
    }
    public static void main(String[] args)
    {
        Base b = new Sub();
    }
}
1.首先，需要明白类的加载顺序。
(1) 父类静态代码块(包括静态初始化块，静态属性，但不包括静态方法)
(2) 子类静态代码块(包括静态初始化块，静态属性，但不包括静态方法 )
(3) 父类非静态代码块( 包括非静态初始化块，非静态属性 )
(4) 父类构造函数
(5) 子类非静态代码块 ( 包括非静态初始化块，非静态属性 )
(6) 子类构造函数
其中：类中静态块按照声明顺序执行，并且(1)和(2)不需要调用new类实例的时候就执行了(意思就是在类加载到方法区的时候执行的)
2.其次，需要理解子类覆盖父类方法的问题，也就是方法重写实现多态问题。
Base b = new Sub();它为多态的一种表现形式，声明是Base,实现是Sub类， 理解为 b 编译时表现为Base类特性，运行时表现为Sub类特性。
当子类覆盖了父类的方法后，意思是父类的方法已经被重写，题中 父类初始化调用的方法为子类实现的方法，子类实现的方法中调用的baseName为子类中的私有属性。
由1.可知，此时只执行到步骤4.,子类非静态代码块和初始化步骤还没有到，子类中的baseName还没有被初始化。所以此时 baseName为空。 所以为null。


byte b1=1,b2=2,b3,b6,b8;
final byte b4=4,b5=6,b7;
b3=(b1+b2);  /*语句1*/
b6=b4+b5;    /*语句2*/
b8=(b1+b4);  /*语句3*/
b7=(b2+b5);  /*语句4*/
System.out.println(b3+b6);
------------知识点------------
Java表达式转型规则由低到高转换：
1、所有的byte,short,char型的值将被提升为int型；
2、如果有一个操作数是long型，计算结果是long型；

3、如果有一个操作数是float型，计算结果是float型；

4、如果有一个操作数是double型，计算结果是double型；
5、被fianl修饰的变量不会自动改变类型，当2个final修饰相操作时，结果会根据左边变量的类型而转化。
--------------解析--------------
语句1错误：b3=(b1+b2);自动转为int，所以正确写法为b3=(byte)(b1+b2);或者将b3定义为int；
语句2正确：b6=b4+b5;b4、b5为final类型，不会自动提升，所以和的类型视左边变量类型而定，即b6可以是任意数值类型；
语句3错误：b8=(b1+b4);虽然b4不会自动提升，但b1仍会自动提升，所以结果需要强转，b8=(byte)(b1+b4);
语句4错误：b7=(b2+b5); 同上。同时注意b7是final修饰，即只可赋值一次，便不可再改变。

javac.exe是编译.java文件
java.exe是执行编译好的.class文件
javadoc.exe是生成Java说明文档
jdb.exe是Java调试器
javaprof.exe是剖析工具